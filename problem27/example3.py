# максимальная подходящая сумма
maxSum = 0


# функция для рекуррентного заполнения массива последовательностями
# остатков, если при этом все их вычесть из исходной суммы и результат
# будет делиться на 6, тогда по массиву остатков возьмём
# столько первых разниц, сколько соответствующих остатков задействовано
def process(pos, arr, d, fsum):
    global maxSum
    # если массив остатков полностью заполнен
    if pos == len(arr):
        # вычитаем из исходной суммы остатки
        subs = fsum
        for j in arr:
            subs -= j

        # если разность делится на 6
        if subs % 6 == 0:
            # номера разностей, которые мы ещё не использовали,
            # пока что все равны 0,
            dPs = [0] * 6
            # перебираем массив остатков
            for i in range(len(arr)):
                # если задействованный остаток равен ноль или
                # мы не встретили достаточное кол-во разниц заданного остатка
                # и они все кончились
                if arr[i] == 0 or d[arr[i]][dPs[i]] == 10000000:
                    # заканчиваем выполнение функции
                    return
                # вычитаем из исходной суммы соответствующую разницу
                fsum -= d[arr[i]][dPs[i]]
                # говорим, что из массива разниц мы взяли ещё одну
                dPs[i] += 1

                # если новая подходящая сумма больше максимальной
            if fsum > maxSum:
                # сохраняем новую сумму в качестве максимальной
                maxSum = fsum


    else:
        # на место pos в массиве остатков ставим по очереди все остатки
        for i in range(len(arr)):
            # для конкретного варианта ставим на меcто pos остаток, равный i
            arr[pos] = i
            # запускаем рекурсию для следующего положения
            process(pos + 1, arr, d, fsum)

# открываем файл, относительный путь строится от папки со скриптом
# можно вместо этого закинуть файл куда-нибудь на диск и указать полный путь
f = open('27-2b.txt')

# читаем кол-во
n = int(f.readline())

# читаем кол-во
# создаём массив для подсчёта подмножеств, сумма которых имеет тот
# или иной остаток от деления на 12
d = [[10000000] * 6] * 6

# изначально сумма чисел равна 0
sum = 0

# читаем сами числа
for i in range(n):
    # читаем строку файла
    line = f.readline()
    # получаем элементы
    elems = line.split(' ')
    # объём хранилища - первый элемент
    a = int(elems[0])
    # кол-во файлов - второй
    b = int(elems[1])

    delta = abs(a - b)
    r = delta % 6

    pos = 0
    while pos < 6 and d[r][pos] <= delta:
        pos += 1
    if pos < 6:
        d[r][pos] = delta
    sum += max(a, b)

# если сумма уже делится на 6
if sum % 6 == 0:
    # выводим её
    print(sum)

else:

    # запускаем перебор остатков
    init = [0, 0, 0, 0, 0, 0]
    process(0, init, d, sum)
    # выводим максимальную сумму
    print(maxSum)
