# ход Пети, результат отвечает на вопрос, выполняется ли первое
# требование задачи,
# s - кол-во камней в куче, step - номер хода
def player1(s, step):
    # если это первый ход Пети, тогда Ваня пока что
    # не сделал ни одного хода
    if step == 1:
        # При любом ходе Пети Ваня должен победить,
        # поэтому используем И
        return player2(s + 1, step) and player2(s + 4, step) and player2(s * 2, step)
    # если это второй ход Пети, т.е. Ваня сделал уже один ход
    elif step == 2:
        # если Ваня при этом победил,
        if s >= 52:
            # требование задачи выполнено
            return True

        # При любом ходе Пети Ваня должен победить,
        # поэтому используем И
        return player2(s + 1, step) and player2(s + 4, step) and player2(s * 2, step)
    # если это третий ход Пети, т.е. Ваня сделал уже два хода
    else:
        # если Ваня при этом победил, то требование задачи не выполнено
        return s >= 52


# ход Вани, результат отвечает на вопрос, выполняется ли первое
# требование задачи,
# s - кол-во камней в куче, step - номер хода
def player2(s, step):
    # обработка состояния игры после хода Пети
    # если Петя сделал первый ход
    if step == 1:
        # если он при этом победил,
        if s >= 52:
            # требование задачи не выполнено
            return False

        # разные ходы Вани
        # у Вани есть стратегия, которая позволит ему гарантированно выиграть первым ходом
        # или вторым ходом, т.е. есть хотя бы один ход, ведущий к победе,
        return player1(s + 1, step + 1) or player1(s + 4, step + 1) or player1(s * 2, step + 1)
    # если Петя сделал второй ход
    else:
        # если он при этом победил,
        if s >= 52:
            # требование задачи не выполнено
            return False

        # у Вани есть стратегия, которая позволит ему гарантированно выиграть первым ходом
        # или вторым ходом, т.е. есть хотя бы один ход, ведущий к победе,
        return player1(s + 1, step + 1) or player1(s + 4, step + 1) or player1(s * 2, step + 1)


# ход Пети, результат отвечает на вопрос, выполняется ли второе
# требование задачи,
# s - кол-во камней в куче, step - номер хода
def checkPlayer1(s, step):
    if step == 1:
        # При любом ходе Пети Ваня не должен гарантированно победить,
        # поэтому отрицаем выражение и используем И
        return not (checkPlayer2(s + 1, step) and checkPlayer2(s + 4, step) and checkPlayer2(s * 2, step))
        # если это второй ход Пети, т.е. Ваня сделал уже один ход
    else:
        # если он при этом победил, возвращаем, что условие выполнено
        return s >= 52

    # ход Вани, результат отвечает на вопрос, выполняется ли второе
    # требование задачи
    # l - кол-во камней в первой куче, r - во второй,  step - номер хода

# ход Вани, результат отвечает на вопрос, выполняется ли второе
# требование задачи
# s - кол-во камней в куче, step - номер хода
def checkPlayer2(s, step):
    # При любом ходе Пети Ваня должен победить,
    #  поэтому используем И
    return checkPlayer1(s + 1, step + 1) or checkPlayer1(s + 4, step + 1) or checkPlayer1(s * 2, step + 1)


# перебираем кол-во камней во второй куче
for s in range(1, 51 + 1):
    # запускаем обработку первого шага Пети, если
    # нас устраивает результат,
    if player1(s, 1) and checkPlayer1(s, 1):
        # выводим кол-во камней во второй куче
        print(s)
        # завершаем цикл
        break
