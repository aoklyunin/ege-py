# ход Пети, результат отвечает на вопрос, выполняется ли первое
# требование задачи,
# l - кол-во камней в первой куче, r - во второй,  step - номер хода
def player1(l, r, step):
    # если это первый ход Пети, тогда Ваня пока что
    # не сделал ни одного хода
    if step == 1:
        # При любом ходе Пети Ваня должен победить,
        # поэтому используем И
        return player2(l + 1, r, step) and player2(l, r + 1, step) \
               and player2(l * 2, r, step) and player2(l, r * 2, step)
    # если это второй ход Пети, т.е. Ваня сделал уже один ход
    elif step == 2:
        # если Ваня при этом победил,
        if l + r >= 77:
            # требование задачи выполнено
            return True

        # При любом ходе Пети Ваня должен победить,
        # поэтому используем И
        return player2(l + 1, r, step) and player2(l, r + 1, step) \
               and player2(l * 2, r, step) and player2(l, r * 2, step)
    # если это третий ход Пети, т.е. Ваня сделал уже два хода
    else:
        # если Ваня при этом победил, то требование задачи не выполнено
        return l + r >= 77


# ход Вани, результат отвечает на вопрос, выполняется ли первое
# требование задачи,
# l - кол-во камней в первой куче, r - во второй,  step - номер хода
def player2(l, r, step):
    # обработка состояния игры после хода Пети
    # если Петя сделал первый ход
    if step == 1:
        # если он при этом победил,
        if l + r >= 77:
            # требование задачи не выполнено
            return False

        # разные ходы Вани
        # у Вани есть стратегия, которая позволит ему гарантированно выиграть первым ходом
        # или вторым ходом, т.е. есть хотя бы один ход, ведущий к победе,
        return player1(l + 1, r, step + 1) or player1(l, r + 1, step + 1) \
               or player1(l * 2, r, step + 1) or player1(l, r * 2, step + 1);
    # если Петя сделал второй ход
    else:
        # если он при этом победил,
        if l + r >= 77:
            # требование задачи не выполнено
            return False

        # у Вани есть стратегия, которая позволит ему гарантированно выиграть первым ходом
        # или вторым ходом, т.е. есть хотя бы один ход, ведущий к победе,
        return player1(l + 1, r, step + 1) or player1(l, r + 1, step + 1) \
               or player1(l * 2, r, step + 1) or player1(l, r * 2, step + 1)


# ход Пети, результат отвечает на вопрос, выполняется ли второе
# требование задачи,
# l - кол-во камней в первой куче, r - во второй,  step - номер хода
def checkPlayer1(l, r, step):
    if step == 1:
        # При любом ходе Пети Ваня не должен гарантированно победить,
        # поэтому отрицаем выражение и используем И
        return not (checkPlayer2(l + 1, r, step) and checkPlayer2(l, r + 1, step) \
                    and checkPlayer2(l * 2, r, step) and checkPlayer2(l, r * 2, step))
        # если это второй ход Пети, т.е. Ваня сделал уже один ход
    else:
        # если он при этом победил, возвращаем, что условие выполнено
        return l + r >= 77

    # ход Вани, результат отвечает на вопрос, выполняется ли второе
    # требование задачи
    # l - кол-во камней в первой куче, r - во второй,  step - номер хода


def checkPlayer2(l, r, step):
    # При любом ходе Пети Ваня должен победить,
    #  поэтому используем И
    return checkPlayer1(l + 1, r, step + 1) or checkPlayer1(l, r + 1, step + 1) \
           or checkPlayer1(l * 2, r, step + 1) or checkPlayer1(l, r * 2, step + 1)


# перебираем кол-во камней во второй куче
for s in range(1, 69 + 1):
    # запускаем обработку первого шага Пети, если
    # нас устраивает результат,
    if player1(7, s, 1) and checkPlayer1(7, s, 1):
        # выводим кол-во камней во второй куче
        print(s)
        # завершаем цикл
        break
